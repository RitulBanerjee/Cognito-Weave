"""
cmu_to_pls.py

Usage:
    python cmu_to_pls.py --input cmudict.txt --output pronunciations.pls
    python cmu_to_pls.py --input small_list.csv --csv --output pronunciations.pls

Input formats supported:
 - CMU dict lines: WORD  PH1 PH2 PH3 ...
 - CSV/TSV: grapheme,phoneme (phoneme may contain spaces, wrap in quotes if needed)
"""

import argparse
import csv
import xml.etree.ElementTree as ET
from xml.dom import minidom
import sys

def parse_cmu_line(line):
    # Remove comments and empty lines
    line = line.strip()
    if not line or line.startswith(";;;") or line.startswith("#"):
        return None
    parts = line.split()
    # CMU dict sometimes has multiple entries like WORD(1)
    grapheme = parts[0]
    phonemes = " ".join(parts[1:])
    return grapheme, phonemes

def parse_csv(file_path, delimiter=','):
    items = []
    with open(file_path, newline='', encoding='utf-8') as f:
        reader = csv.reader(f, delimiter=delimiter)
        for row in reader:
            if not row: 
                continue
            # Expect at least two columns: grapheme and phoneme
            grapheme = row[0].strip()
            phoneme = row[1].strip() if len(row) > 1 else ""
            if grapheme:
                items.append((grapheme, phoneme))
    return items

def build_pls(lexemes, alphabet="cmu", xml_lang="en-US"):
    # root lexicon element
    ns = "http://www.w3.org/2005/01/pronunciation-lexicon"
    ET.register_namespace('', ns)
    root = ET.Element("{%s}lexicon" % ns, {
        "version": "1.0",
        "alphabet": alphabet,
        "xml:lang": xml_lang
    })
    for grapheme, phoneme in lexemes:
        lexeme = ET.SubElement(root, "lexeme")
        g = ET.SubElement(lexeme, "grapheme")
        g.text = grapheme
        if phoneme:
            p = ET.SubElement(lexeme, "phoneme")
            p.text = phoneme
        else:
            # if no phoneme provided, you might want an alias (uncomment if desired)
            # a = ET.SubElement(lexeme, "alias")
            # a.text = grapheme
            pass
    return root

def prettify_xml(elem):
    raw = ET.tostring(elem, encoding='utf-8')
    parsed = minidom.parseString(raw)
    return parsed.toprettyxml(indent="  ", encoding='utf-8')

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--input', '-i', required=True, help='Input file (CMU dict or CSV)')
    ap.add_argument('--output', '-o', required=True, help='Output .pls file')
    ap.add_argument('--csv', action='store_true', help='Treat input as CSV/TSV (default: CMU dict)')
    ap.add_argument('--delimiter', '-d', default=',', help='CSV delimiter (default ,)')
    ap.add_argument('--lang', default='en-US', help='xml:lang attribute (default en-US)')
    args = ap.parse_args()

    lexemes = []
    if args.csv:
        lexemes = parse_csv(args.input, delimiter=args.delimiter)
    else:
        # parse CMU-style file
        with open(args.input, 'r', encoding='utf-8') as f:
            for line in f:
                parsed = parse_cmu_line(line)
                if parsed:
                    grapheme, phoneme = parsed
                    # normalize grapheme to lower-case or keep as original depending on need
                    lexemes.append((grapheme, phoneme))

    root = build_pls(lexemes, alphabet="cmu", xml_lang=args.lang)
    pretty = prettify_xml(root)

    with open(args.output, 'wb') as out:
        # write XML declaration manually to match example
        out.write(b'<?xml version="1.0" encoding="UTF-8"?>\n')
        out.write(pretty)

    print(f"Wrote {len(lexemes)} lexemes to {args.output}")

if __name__ == "__main__":
    main()
